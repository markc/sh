#!/usr/bin/env bash
# Created: 20150101 - Updated: 20250804
# Copyright (C) 1995-2025 Mark Constable <mc@netserva.org> (MIT License)
#
# Shell resource configuration - aliases and functions
# This file contains useful aliases and bash functions extracted from
# the NetServa management system. Source this in your ~/.bashrc:
# [[ -f ~/.sh/shrc.sh ]] && . ~/.sh/shrc.sh


# Detect OS type
detect_os() {
    local uname_s=$(uname -s | tr 'A-Z' 'a-z')
    local uname_m=$(uname -m)

    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        case "${ID:-}" in
        alpine | debian | ubuntu | cachyos | manjaro | arch | openwrt)
            OSTYP="$ID"
            ;;
        *)
            case "${ID_LIKE:-}" in
            *debian*) OSTYP="debian" ;;
            *arch*) OSTYP="arch" ;;
            *) OSTYP="${ID:-$uname_s}" ;;
            esac
            ;;
        esac
    elif [[ -f /etc/openwrt_release ]]; then
        OSTYP="openwrt"
    elif [[ "$uname_s" == "darwin" ]]; then
        OSTYP="macos"
    else
        OSTYP="$uname_s"
    fi

    case "$uname_m" in
    x86_64 | amd64) ARCH="x86_64" ;;
    aarch64 | arm64) ARCH="arm64" ;;
    armv7l | armhf) ARCH="armv7" ;;
    *) ARCH="$uname_m" ;;
    esac

    export OSTYP ARCH
}

# Initialize environment
detect_os

# Set SUDO if not root
unalias sudo 2>/dev/null || true
SUDO=$([[ $(id -u) -gt 0 ]] && echo '/usr/bin/sudo ')
export SUDO

# ========== REMOTE SERVER COMPATIBILITY ==========
# These variables are conditionally set for NetServa compatibility
# On remote servers, ~/.ns/ may not exist, so these are optional

# Only set NetServa variables if ~/.ns exists (central workstation)
if [[ -d "$HOME/.ns" ]]; then
    # Core directory structure (5-char naming convention)
    NSDIR="${NSDIR:-$HOME/.ns}"           # NetServa Directory (root)
    NSBIN="${NSBIN:-$NSDIR/bin}"          # NetServa Binaries
    NSLIB="${NSLIB:-$NSDIR/lib}"          # NetServa Libraries
    NSETC="${NSETC:-$NSDIR/etc}"          # NetServa Configuration templates
    NSDOC="${NSDOC:-$NSDIR/doc}"          # NetServa Documentation
    NSMAN="${NSMAN:-$NSDIR/man}"          # NetServa Manual pages
    NSVAR="${NSVAR:-$NSDIR/var}"          # NetServa Variable data (vhost configs)
    NSRUN="${NSRUN:-$NSDIR/run}"          # NetServa Runtime (OpenTofu/Terraform)
    NSMNT="${NSMNT:-$NSDIR/mnt}"          # NetServa Mount points (SSHFS)
    NSTMP="${NSTMP:-$NSDIR/tmp}"          # NetServa Temporary files
    NSWWW="${NSWWW:-$NSDIR/www}"          # NetServa Web files
    NSLOG="${NSLOG:-$NSDIR/log}"          # NetServa Log files (if needed)
    NSBAK="${NSBAK:-$NSDIR/bak}"          # NetServa Backups (if needed)

    # Additional NSIS directories
    NSCFG="${NSCFG:-$NSDIR/cfg}"          # NetServa Config templates
    
    # SSH-related paths  
    NSKEY="${NSKEY:-$HOME/.ssh/keys}"     # NetServa SSH Keys directory
    NSSSH="${NSSSH:-$HOME/.ssh/config.d}" # NetServa SSH host configs

    # Project metadata
    NSPRJ="${NSPRJ:-NetServa}"            # Project name
    NSVER="${NSVER:-0.1.0}"               # NetServa version
    NSBLD="${NSBLD:-2025-08-12}"          # Build date

    # Export all NS* variables for child processes
    export NSDIR NSBIN NSLIB NSETC NSDOC NSMAN NSVAR NSRUN NSMNT NSTMP NSWWW
    export NSLOG NSBAK NSCFG NSKEY NSSSH NSPRJ NSVER NSBLD

    # Add NetServa bin to PATH if it exists and not already in PATH
    if [[ -d "$NSBIN" ]] && [[ ":$PATH:" != *":$NSBIN:"* ]]; then
        export PATH="$NSBIN:$PATH"
    fi
fi

# Note: Custom user configuration is loaded at the end of this file

# ========== ALIASES ==========

# Navigation and file management
alias ..='cd ..'
alias df='df -kTh'
alias la='LC_COLLATE=C ls -lFAh --group-directories-first --color'
alias ll='LC_COLLATE=C ls -lF --group-directories-first --color'
alias ls='LC_COLLATE=C ls -F --group-directories-first --color'

# Editors
alias e='nano -t -x -c'
alias se='sudo nano -t -x -c'

# System tools
alias ff="fastfetch --logo none --colors-block-width 0"
alias p='ps auxxww | grep -v grep | grep'
alias q='find -type f -print0 | xargs -0 grep '
alias wt="curl -s -w '%{time_total}\n' -o /dev/null"

# Notes
alias n='echo -e "-- $(date) --\n" >> ~/.note && e +10000 ~/.note'
alias sn='[ -f ~/.note ] && cat ~/.note'

# Help and configuration
alias ?='bash ~/.help'
alias eh='e ~/.help'
alias es='e ~/.myrc; source ~/.shrc'
alias m='bash ~/.menu'

# Package management aliases based on OS type
if [[ $OSTYP == openwrt ]]; then
    alias edpkg=$SUDO'nano -t -x -c /etc/opkg/customfeeds.conf'
    alias i=$SUDO'opkg install'
    alias l=$SUDO'logread -f'
    alias lspkg=$SUDO'opkg list-installed | sort | grep'
    alias p='ps | grep -v grep | grep'
    alias r=$SUDO'opkg remove'
    alias s=$SUDO'opkg list | sort | grep '
    alias u=$SUDO'opkg update && '$SUDO'opkg list-upgradable | cut -f 1 -d " " | xargs -r opkg upgrade'
    alias ram=$SUDO"ps w | grep -v \"   0\" | awk '{print \$3\"\t\"\$5\" \"\$6\" \"\$7\" \"\$8\" \"\$9}' | sort -n"
elif [[ $OSTYP == alpine ]]; then
    alias edpkg=$SUDO'nano -t -x -c /etc/apk/repositories'
    alias i=$SUDO'apk add'
    alias l=$SUDO'tail -f /var/log/messages'
    alias lspkg=$SUDO'apk info | sort | grep'
    alias r=$SUDO'apk del'
    alias ram='ps ax -o rss,vsz,comm | grep -v "   0" | sort -n'
    alias s=$SUDO'apk search -v'
    alias u=$SUDO'apk update && '$SUDO'apk upgrade'
elif [[ $OSTYP == manjaro || $OSTYP == cachyos || $OSTYP == arch ]]; then
    alias edpkg=$SUDO'nano -t -x -c /etc/pacman.conf'
    alias i=$SUDO'pacman -S'
    alias lspkg=$SUDO'pacman -Qs'
    alias r=$SUDO'pacman -Rns'
    alias s=$SUDO'pacman -Ss'
    alias u=$SUDO'pacman -Syu --noconfirm ; '$SUDO' pacman -Scc --noconfirm'
    alias uu='yay -Syyuu --noconfirm ; yay -Scc --noconfirm ; '$SUDO' pacman -Scc --noconfirm'
    alias ram='ps -eo rss:10,vsz:10,%cpu:5,cmd --sort=rss | grep -v "^\s\+0" | cut -c -79'
else
    alias aptkey=$SUDO'apt-key adv --recv-keys --keyserver keyserver.ubuntu.com'
    alias edpkg=$SUDO'nano -t -x -c /etc/apt/sources.list'
    alias i=$SUDO'apt-get install'
    alias lspkg='dpkg --get-selections | awk "{print \$1}" | sort | grep'
    alias r=$SUDO'apt-get remove --purge'
    alias s='apt-cache search'
    alias u=$SUDO'apt-get update && '$SUDO'apt-get -y -f dist-upgrade && '$SUDO'apt-get -y autoremove && '$SUDO'apt-get clean'
    alias ram='ps -eo rss:10,vsz:10,%cpu:5,cmd --sort=rss | grep -v "^\s\+0" | cut -c -79'
fi

# Log viewing aliases
alias l='journalctl -f'
alias dlog='journalctl -f -t pdns_server -t pdns_recursor'
alias hlog='journalctl -f -t hlog'
alias slog='journalctl -f -t sshd'
alias mlog='tail -f /var/log/mail.log'
alias mgrep='mlog | grep '
alias alog='tail -f ../log/access.log'
alias elog='tail -f /var/log/nginx/error.log'
alias plog='tail -f ../log/php-errors.log'

# Firewall/security aliases
alias shblock="nft list set ip sshguard attackers | tr '\n' ' '| sed 's/.*elements = {\([^}]*\)}.*/\1\n/' | sed -r 's/\s+//g' | tr ',' '\n'"
alias oldblock='iptables -A INPUT -j DROP -s '
alias oldshblock='iptables -L -n | grep ^DROP | awk '\''{print $4}'\'' | sort -n'
alias oldunblock='iptables -D INPUT -j DROP -s '

# Mail log processing
alias maillog="journalctl -f -n 10000 | stdbuf -oL grep 'warning: header Subject:' | sed -e 's/mail .*warning: header Subject:\(.*\)/\1/' -e 's/ from .*];//' -e 's/proto=.*$//'"

# Server management tools
alias ports='ss -tuln'              # Show listening ports
alias procs='ps aux --sort=-%cpu | head -20'  # Top CPU processes
alias disk='df -h'                  # Disk usage human readable
alias mem='free -h'                 # Memory usage human readable
alias temp='sensors 2>/dev/null || cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null'
alias netcon='ss -tuln | grep LISTEN'  # Network connections
alias sysinfo='uname -a && uptime && free -h && df -h /'
alias listening='netstat -tuln 2>/dev/null || ss -tuln'
alias top10='ps aux --sort=-%cpu | head -11'  # Top 10 CPU processes

# Log monitoring (adjust paths for different systems)
alias logs='journalctl -f'
alias syslog='tail -f /var/log/syslog 2>/dev/null || tail -f /var/log/messages 2>/dev/null || journalctl -f'
alias authlog='tail -f /var/log/auth.log 2>/dev/null || journalctl -f -u ssh'

# Service shortcuts
alias systemd='systemctl'
alias services='systemctl list-units --type=service --state=running'
alias failed='systemctl list-units --failed'

# Security monitoring
alias lastlog='last | head -10'
alias failedlogins='journalctl -t sshd | grep "Failed password" | tail -10'
alias connections='ss -tuln | grep :22'  # SSH connections

# Additional tools
alias a='php artisan'
alias c='composer'
alias lx='lxc list'
alias hcp='shm pull; su - sysadm -c "cd var/www/html/hcp; git pull"'

# ========== FUNCTIONS ==========

# Find files by name pattern
f() {
    if [[ ${OSTYP:-} == openwrt ]]; then
        find . -type f -iname '*'$*'*'
    else
        find . -type f -iname '*'$*'*' -ls
    fi
}

# Service control wrapper
if [[ ${OSTYP:-} == openwrt ]]; then
    sc() { $SUDO /etc/init.d/$2 $1; }
    function getent {
        if [[ $1 == passwd ]]; then
            cat /etc/passwd
        elif [[ $1 == group ]]; then
            cat /etc/group
        fi
    }
    export -f getent
elif [[ ${OSTYP:-} == alpine ]]; then
    sc() {
        # Convert systemd-style service@instance to OpenRC service.instance
        if [[ "$2" == *"@"* ]]; then
            local service_name="${2/@/.}"
        else
            local service_name="$2"
        fi

        # Helper function for WireGuard cleanup
        wg_cleanup() {
            local wg_interface="${service_name#wg-quick.}"
            wg-quick down "$wg_interface" 2>/dev/null || true
        }

        # Handle common actions
        case "$1" in
        enable)
            $SUDO rc-update add "$service_name"
            ;;
        disable)
            $SUDO rc-update del "$service_name"
            ;;
        status)
            $SUDO rc-service "$service_name" status
            ;;
        restart)
            if [[ "$service_name" == wg-quick.* ]]; then
                wg_cleanup
                $SUDO rc-service "$service_name" stop 2>/dev/null || true
            else
                $SUDO rc-service "$service_name" stop
            fi
            $SUDO rc-service "$service_name" start
            ;;
        start)
            [[ "$service_name" == wg-quick.* ]] && wg_cleanup
            $SUDO rc-service "$service_name" start
            ;;
        stop)
            $SUDO rc-service "$service_name" stop
            [[ "$service_name" == wg-quick.* ]] && wg_cleanup
            ;;
        *)
            $SUDO rc-status --all | awk '/\[.*\]/ {print $1}'
            ;;
        esac
    }
else
    sc() {
        if [[ -z $1 ]]; then
            $SUDO systemctl list-units --type=service | awk 'NR>1 {sub(".service", "", $1); print $1}' | head -n -7
        else
            $SUDO systemctl $1 $2
        fi
    }
fi

# Check if file is older than specified seconds
chktime() {
    [[ $(($(stat -c %X $1) + $2)) < $(date +%s) ]] && return 0 || return 1
}

# Get users with UID between 1000-9999
getusers() {
    getent passwd | awk -F: '{if ($3 > 999 && $3 < 9999) print}'
}

# Display user info
getuser() {
    echo "\
UUSER=$UUSER
U_UID=$U_UID
U_GID=$U_GID
VHOST=$VHOST
UPATH=$UPATH
U_SHL=$U_SHL"
}

# Navigate to user directories (temporary old path)
go2() {
    if [[ -d /var/ns ]]; then
        # New path structure
        if [[ $1 =~ "@" ]]; then
            cd /var/ns/${1#*@}*/mail/${1%@*}
        else
            cd /var/ns/$1*/var/www/public
        fi
    else
        # Old path structure
        if [[ $1 =~ "@" ]]; then
            cd /home/u/${1#*@}*/home/*${1%@*}
        else
            cd /home/u/$1*/var/www
        fi
    fi
}

# Search for user in system
grepuser() {
    getusers | grep -E "$1[,:]"
}

# Git shortcuts for .sh repo
shpull() {
    cd "$HOME/.sh"
    git pull
}

shpush() {
    cd "$HOME/.sh"
    if [[ -n "$1" ]]; then
        git commit -am "$*"
    else
        git commit -a
    fi
    git push
}

# Note: Git shortcuts for .ns repo (nspull, nspush) provided by ~/.ns/etc/netserva.sh

# Show database command
getdb() {
    echo $SQCMD
}

# SSH with interactive shell
sx() {
    [[ -z $2 || $1 =~ -h ]] &&
        echo "Usage: sx host command (host must be in ~/.ssh/config)" && return 1
    local _HOST=$1
    shift
    {
        ssh $_HOST -q -t "bash -ci '$@'" 2>&1
    } | {
        while IFS= read -r line; do
            [[ $line != *"bash: cannot set terminal process group"* ]] && \
            [[ $line != *"bash: no job control"* ]] && \
            echo "$line"
        done
    }
}

# Quick server health check
health() {
    echo "=== System Health Check ==="
    echo "Date: $(date)"
    echo "Uptime: $(uptime -p 2>/dev/null || uptime)"
    echo "Load: $(cat /proc/loadavg)"
    echo
    echo "=== Memory Usage ==="
    free -h
    echo
    echo "=== Disk Usage ==="
    df -h / | tail -1
    echo
    echo "=== Top Processes (CPU) ==="
    ps aux --sort=-%cpu | head -6
    echo
    echo "=== Network Connections ==="
    ss -tuln | grep LISTEN | wc -l | xargs echo "Listening ports:"
    echo
    echo "=== Recent Failed Logins ==="
    if command -v journalctl >/dev/null 2>&1; then
        journalctl -t sshd --since "1 hour ago" 2>/dev/null | grep -c "Failed password" | xargs echo "Failed SSH attempts in last hour:"
    else
        echo "journalctl not available"
    fi
}

# Show process tree for a service
pstree_service() {
    [[ -z $1 ]] && { echo "Usage: pstree_service <service_name>"; return 1; }
    local service="$1"
    local pid
    
    if command -v systemctl >/dev/null 2>&1; then
        pid=$(systemctl show --property MainPID --value "$service" 2>/dev/null)
    else
        pid=$(pgrep -f "$service" | head -1)
    fi
    
    if [[ -n "$pid" && "$pid" != "0" ]]; then
        echo "Process tree for $service (PID: $pid):"
        pstree -p "$pid" 2>/dev/null || ps --forest -o pid,ppid,cmd -p "$pid"
    else
        echo "Service $service not running or not found"
    fi
}


# Set default color and label
COLOR=${COLOR:-31}
LABEL=$(hostname)

# Load custom user configuration to allow overriding defaults
[[ -f ~/.myrc ]] && . ~/.myrc

# Load NetServa environment if available (for extended NSCM functionality)
[[ -f ~/.ns/etc/netserva.sh ]] && source ~/.ns/etc/netserva.sh

# Export commonly used functions
export -f chktime f getdb getuser getusers go2 grepuser sc sx health pstree_service
export -f detect_os shpull shpush

# Set colored prompt
PS1="\[\033[1;${COLOR}m\]${LABEL} \w\[\033[0m\] "
export PS1
